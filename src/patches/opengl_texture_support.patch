--- a/renderer/src/gl/render_context_gl_impl.cpp	2025-11-28 03:46:09
+++ b/renderer/src/gl/render_context_gl_impl.cpp	2025-11-30 04:50:49
@@ -221,10 +221,11 @@
                                               std::size(colorRampSources),
                                               m_capabilities);
     m_colorRampProgram.link();
-    glUniformBlockBinding(
-        m_colorRampProgram,
-        glGetUniformBlockIndex(m_colorRampProgram, GLSL_FlushUniforms),
-        FLUSH_UNIFORM_BUFFER_IDX);
+    {
+        GLuint blockIndex = glGetUniformBlockIndex(m_colorRampProgram, GLSL_FlushUniforms);
+        if (blockIndex != GL_INVALID_INDEX)
+            glUniformBlockBinding(m_colorRampProgram, blockIndex, FLUSH_UNIFORM_BUFFER_IDX);
+    }
 
     m_state->bindVAO(m_colorRampVAO);
     glEnableVertexAttribArray(0);
@@ -281,10 +282,11 @@
     glutils::Uniform1iByName(m_tessellateProgram,
                              GLSL_featherTexture,
                              FEATHER_TEXTURE_IDX);
-    glUniformBlockBinding(
-        m_tessellateProgram,
-        glGetUniformBlockIndex(m_tessellateProgram, GLSL_FlushUniforms),
-        FLUSH_UNIFORM_BUFFER_IDX);
+    {
+        GLuint blockIndex = glGetUniformBlockIndex(m_tessellateProgram, GLSL_FlushUniforms);
+        if (blockIndex != GL_INVALID_INDEX)
+            glUniformBlockBinding(m_tessellateProgram, blockIndex, FLUSH_UNIFORM_BUFFER_IDX);
+    }
     if (!m_capabilities.ARB_shader_storage_buffer_object)
     {
         // Our GL driver doesn't support storage buffers. We polyfill these
@@ -634,7 +636,9 @@
         // WebGL doesn't support buffer mapping. Don't use it on ANGLE either
         // since we don't trust ANGLE with features that haven't been validated
         // by WebGL.
-        if (!m_state->capabilities().isANGLESystemDriver)
+        // Also disable on Windows/Godot to avoid "Buffer must be bound and not mapped" errors
+        // and ensure stability with the Compatibility backend.
+        if (false && !m_state->capabilities().isANGLESystemDriver)
         {
             m_state->bindBuffer(m_target, m_bufferID);
             return glMapBufferRange(m_target,
@@ -657,7 +661,7 @@
         // WebGL doesn't support buffer mapping. Don't use it on ANGLE either
         // since we don't trust ANGLE with features that haven't been validated
         // by WebGL.
-        if (!m_state->capabilities().isANGLESystemDriver)
+        if (false && !m_state->capabilities().isANGLESystemDriver)
         {
             glUnmapBuffer(m_target);
         }
@@ -915,9 +919,11 @@
                                      capabilities);
     m_program.link();
     state->bindProgram(m_program);
-    glUniformBlockBinding(m_program,
-                          glGetUniformBlockIndex(m_program, GLSL_FlushUniforms),
-                          FLUSH_UNIFORM_BUFFER_IDX);
+    {
+        GLuint blockIndex = glGetUniformBlockIndex(m_program, GLSL_FlushUniforms);
+        if (blockIndex != GL_INVALID_INDEX)
+            glUniformBlockBinding(m_program, blockIndex, FLUSH_UNIFORM_BUFFER_IDX);
+    }
     glutils::Uniform1iByName(m_program,
                              GLSL_tessVertexTexture,
                              TESS_VERTEX_TEXTURE_IDX);
@@ -1431,9 +1437,11 @@
     }
 
     m_state->bindProgram(m_id);
-    glUniformBlockBinding(m_id,
-                          glGetUniformBlockIndex(m_id, GLSL_FlushUniforms),
-                          FLUSH_UNIFORM_BUFFER_IDX);
+    {
+        GLuint blockIndex = glGetUniformBlockIndex(m_id, GLSL_FlushUniforms);
+        if (blockIndex != GL_INVALID_INDEX)
+            glUniformBlockBinding(m_id, blockIndex, FLUSH_UNIFORM_BUFFER_IDX);
+    }
 
     const bool isImageDraw = gpu::DrawTypeIsImageDraw(drawType);
     const bool isTessellationDraw = is_tessellation_draw(drawType);
@@ -1445,10 +1453,9 @@
                              gpu::ShaderMiscFlags::borrowedCoveragePass));
     if (isImageDraw)
     {
-        glUniformBlockBinding(
-            m_id,
-            glGetUniformBlockIndex(m_id, GLSL_ImageDrawUniforms),
-            IMAGE_DRAW_UNIFORM_BUFFER_IDX);
+        GLuint blockIndex = glGetUniformBlockIndex(m_id, GLSL_ImageDrawUniforms);
+        if (blockIndex != GL_INVALID_INDEX)
+            glUniformBlockBinding(m_id, blockIndex, IMAGE_DRAW_UNIFORM_BUFFER_IDX);
     }
     if (isTessellationDraw)
     {
@@ -2521,6 +2528,16 @@
                "%u.%u",
                &capabilities.contextVersionMajor,
                &capabilities.contextVersionMinor);
+
+        // Force GLES mode for Desktop GL < 4.0 to support Godot's OpenGL 3 backend (GL 3.3)
+        if (capabilities.contextVersionMajor < 4)
+        {
+            capabilities.isGLES = true;
+            // Clamp to 3.0 to avoid enabling GLES 3.1+ features (SSBO, Images) 
+            // which are not guaranteed in Desktop GL 3.3.
+            capabilities.contextVersionMajor = 3;
+            capabilities.contextVersionMinor = 0;
+        }
     }
     else if (capabilities.isPowerVR)
     {
@@ -2539,9 +2556,9 @@
                &capabilities.contextVersionMinor);
     }
 #ifdef RIVE_DESKTOP_GL
-    assert(capabilities.contextVersionMajor == GLAD_GL_version_major);
-    assert(capabilities.contextVersionMinor == GLAD_GL_version_minor);
-    assert(capabilities.isGLES == static_cast<bool>(GLAD_GL_version_es));
+    // assert(capabilities.contextVersionMajor == GLAD_GL_version_major);
+    // assert(capabilities.contextVersionMinor == GLAD_GL_version_minor);
+    // assert(capabilities.isGLES == static_cast<bool>(GLAD_GL_version_es));
 #endif
 
     if (capabilities.isGLES)
@@ -2612,6 +2629,16 @@
         capabilities.EXT_clip_cull_distance = true;
     }
 
+    // Force disable advanced features if we are forcing GLES 3.0 mode for compatibility
+    if (capabilities.isGLES && capabilities.contextVersionMajor == 3 && capabilities.contextVersionMinor == 0)
+    {
+        capabilities.ARB_shader_storage_buffer_object = false;
+        capabilities.OES_shader_image_atomic = false;
+        capabilities.ARB_shader_image_load_store = false;
+        capabilities.EXT_base_instance = false;
+        capabilities.ANGLE_base_vertex_base_instance_shader_builtin = false;
+    }
+
 #ifndef RIVE_WEBGL
     GLint extensionCount;
     glGetIntegerv(GL_NUM_EXTENSIONS, &extensionCount);
@@ -2622,7 +2649,8 @@
         if (strcmp(ext, "GL_ANGLE_base_vertex_base_instance_shader_builtin") ==
             0)
         {
-            capabilities.ANGLE_base_vertex_base_instance_shader_builtin = true;
+            if (!(capabilities.isGLES && capabilities.contextVersionMajor == 3 && capabilities.contextVersionMinor == 0))
+                capabilities.ANGLE_base_vertex_base_instance_shader_builtin = true;
         }
         else if (strcmp(ext, "GL_ANGLE_shader_pixel_local_storage") == 0)
         {
@@ -2651,15 +2679,18 @@
         }
         else if (strcmp(ext, "GL_ARB_shader_image_load_store") == 0)
         {
-            capabilities.ARB_shader_image_load_store = true;
+            if (!(capabilities.isGLES && capabilities.contextVersionMajor == 3 && capabilities.contextVersionMinor == 0))
+                capabilities.ARB_shader_image_load_store = true;
         }
         else if (strcmp(ext, "GL_ARB_shader_storage_buffer_object") == 0)
         {
-            capabilities.ARB_shader_storage_buffer_object = true;
+            if (!(capabilities.isGLES && capabilities.contextVersionMajor == 3 && capabilities.contextVersionMinor == 0))
+                capabilities.ARB_shader_storage_buffer_object = true;
         }
         else if (strcmp(ext, "GL_OES_shader_image_atomic") == 0)
         {
-            capabilities.OES_shader_image_atomic = true;
+            if (!(capabilities.isGLES && capabilities.contextVersionMajor == 3 && capabilities.contextVersionMinor == 0))
+                capabilities.OES_shader_image_atomic = true;
         }
         else if (strcmp(ext, "GL_KHR_blend_equation_advanced") == 0)
         {
@@ -2675,7 +2706,8 @@
         }
         else if (strcmp(ext, "GL_EXT_base_instance") == 0)
         {
-            capabilities.EXT_base_instance = true;
+            if (!(capabilities.isGLES && capabilities.contextVersionMajor == 3 && capabilities.contextVersionMinor == 0))
+                capabilities.EXT_base_instance = true;
         }
         else if (strcmp(ext, "GL_EXT_clip_cull_distance") == 0 ||
                  strcmp(ext, "GL_ANGLE_clip_cull_distance") == 0)
--- a/renderer/src/gl/render_buffer_gl_impl.cpp	2025-11-28 03:46:09
+++ b/renderer/src/gl/render_buffer_gl_impl.cpp	2025-11-30 04:55:23
@@ -107,7 +107,7 @@
 {
     // WebGL doesn't support buffer mapping. Don't use it on ANGLE either since
     // we don't trust ANGLE with features that haven't been validated by WebGL.
-    return !m_state->capabilities().isANGLESystemDriver &&
+    return false && !m_state->capabilities().isANGLESystemDriver &&
            // NVIDIA gives performance warnings when mapping GL_STATIC_DRAW
            // buffers.
            !(flags() & RenderBufferFlags::mappedOnceAtInitialization);
